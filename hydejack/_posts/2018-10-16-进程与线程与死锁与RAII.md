---
layout: post
title: 进程与线程与死锁与RAII资源管理
author: author1
description: >
&ensp;&ensp;学习c++离不开操作系统与网络编程, 以下所有观点来自个人理解，如果出错，请联系我。
参考：https://blog.csdn.net/woaigaolaoshi/article/details/51039505?utm_source=copy
---

## 进程与线程与死锁与RAII资源管理

### 一.程序与进程的区别
> 程序并不能单独执行，只有将程序加载到内存中，系统为他**分配资源**后才能够执行，这种**执行的程序**称之为进程，也就是说进程是系统进行资源分配和调度的一个独立单位，每个进程都有自己单独的地址空间。所以说程序与进程的区别在于，程序是指令的集合，是进程运行的静态说明书，而进程则是程序(按说明书)在系统上顺序执行时的动态活动。
总结:
1. 程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；
2. 程序是静态的观念，进程是动态的观念；
3. 进程具有并发性，而程序没有；
4. 进程是竞争计算机资源的基本单位，程序不是。
5. 进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序
6. 进程是分配在内存中 处于执行期的动态程序, 但进程并不仅仅局限于一段可执行程序代码。通常进程还要包含其他资源，像打开的文件，挂起的信号，内核内部数据，持利器状态，一个或多个具有内存映射的内存地址空间以及一个或多个执行线程，当然还包括用来存放全局变量的数据段等。
--------------------- 

### 二.进程与线程的区别
> 进程是操作系统分配资源的单位。线程(Thread)是进程的一个实体,是CPU调度和分派的基本单位 
总结:
1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
2. 线程的划分尺度小于进程，使得多线程程序的并发性高。
3. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4. 一个进程崩溃后，在保护模式下不会对其它进程产生影响, 但一个线程死掉就等于整个进程死掉
5. 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
---------------------

######	进程与线程的优缺点:
(1) 在进程内创建、终止线程比创建、终止进程要快；   
(2) 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。   
(3) 线程的可移植性并不好

### 三.并行与并发
总线程数<= CPU数量：并行运行   
总线程数> CPU数量：并发运行

并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算机中只运行一个进程(线程)，就不能发挥多CPU的优势。

 多任务操作系统(如Windows)的基本原理是:操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的).操作系统不断的从一个线程的执行切换到另一个线程的执行,如此往复,宏观上看来,就好像是多个线程在一起执行.由于这多个线程分属于不同的进程,因此在我们看来,就好像是多个进程在同时执行,这样就实现了多任务.

##### 操作系统的设计
对操作系统 而言:
1. 以多进程形式，允许多个任务同时运行； 
2. 以多线程形式，允许单个任务分成不同的部分运行； 
3. 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。

> Linux认为线程与进程是一样的, 所以调度解决的对象是线程而不是进程.Linux系统是一个多进程的系统，它的进程之间具有并行性、互不干扰等特点。 
也就是说，每个进程都是一个独立的运行单位，拥有各自的权利和责任。其中，各个进程都运行在独立的虚拟地址空间，因此，即使一个进程发生异常，它也不会影响到系统中的其他进程。

> Linux中的进程包含3个段，分别为“数据段”、“代码段”和“堆栈段”。 
“数据段”存放的是全局变量、常数以及动态数据分配的数据空间； 
“代码段”存放的是程序代码的数据。 
“堆栈段”存放的是子程序的返回地址、子程序的参数以及程序的局部变量等。

> Linux系统下的多线程遵循POSIX线程接口，称为pthread。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用libpthread.a

---------------------
<br>
<br>
<br>

### 四. 操作系统资源管理机制与RAII资源管理
> 锁是多进程与多线程系统中 保证安全的一种机制.在多线程编程中，通过锁机制能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的**一致性**。
首先引如互斥锁的简单抽象概念: [点我](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
```
加锁过程用如下伪码表示： 
1、read lock； 
2、判断lock状态； 
3、如果已经加锁，失败返回； 
4、把锁状态设置为上锁； 
5、返回成功。 
```
如果资源不上锁， 会导致什么呢？   
**ans**:  比如， 两个线程 占据了同一个资源，然后a进程完成相应任务 销毁了一些对象与数据。此时b线程会崩溃，从而导致程序的崩溃.

##### c++中的RAII资源管理机制
> 在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。 是c++控制资源的一种常见方式。

##### 常见RAII对象
boots 也是 c++11 的 shared_ptr 和 wea_ptr std::auto_ptr<>   
本人仿照着写了一个 链接：[Joe_smart_ptr](www.hao123.com)


##### RAII机制的使用，给资源上锁, 以保证多线程下的安全
---------------------
<br>
<br>


### 五. 死锁
 死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种**永久等待**状态。
eg:如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1
```
产生死锁的四个必要条件：
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
```
###### 死锁类型
死锁有很多种类型 如 共享锁 排他锁 递归死锁 死锁预防等等

###### 死锁预防
```
我们已经知道，出现死锁要满足4个必要条件，只要确保一个必要条件不成立，就能预防死锁发生。
下面通过讨论这4个必要条件来研究死锁预防方法。   
1. 互斥：共享资源不是必须的，而非共享资源必须保持互斥   
2. 占有并等待：必须保证进程申请资源的时候没有占有其他资源   
　　·要求进程在执行前一次申请全部的资源，只有没有占有资源时才可以分配资源   
　　·利用率低，可能出现饥饿   
3. 非抢占：如果一个进程的申请没有实现，它要释放所有占有的资源   
4. 循环等待：将所有的资源类型放入资源列表中，并且要求进程按照资源表中递增的顺序申请资源
```

---------------------













